<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Rust Imaging Library. A performant and high-level image processing crate for Rust."><title>ril - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ril" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ril/index.html">ril</a><span class="version">0.10.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">ril</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/ril/lib.rs.html#1-351">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The Rust Imaging Library. A performant and high-level image processing crate for Rust.</p>
<p>See benchmarks and more by viewing the <a href="https://github.com/jay3332/ril#ril">README</a>. It should
also be noted that the README is updated more frequently than the documentation.</p>
<p>Similarly, you can see the changelog <a href="https://github.com/jay3332/ril/blob/main/CHANGELOG.md">here</a>.</p>
<h2 id="installation"><a class="doc-anchor" href="#installation">§</a>Installation</h2>
<p>The MSRV (Minimum Supported Rust Version) of this crate is <strong>v1.61.0</strong>.</p>
<p>Add the following to your <code>Cargo.toml</code> dependencies:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { version = &quot;0&quot;, features = [&quot;all&quot;] ]
</code></pre></div><h3 id="installing-from-github"><a class="doc-anchor" href="#installing-from-github">§</a>Installing from GitHub</h3>
<p>You can also use the unstable but latest version by installing from GitHub:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { git = &quot;https://github.com/jay3332/ril&quot;, branch = &quot;main&quot;, features = [&quot;all&quot;] }
</code></pre></div><h3 id="using-cargo-add"><a class="doc-anchor" href="#using-cargo-add">§</a>Using <code>cargo add</code></h3>
<p>If you have cargo &gt;= 1.62.0, you can use <code>cargo add ril --features=all</code>.</p>
<h3 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo Features</h3>
<p>RIL currently depends on a few dependencies for certain features - especially for various image encodings.
By default RIL comes with no encoding dependencies but with the <code>text</code> and <code>resize</code> dependencies, which give you text
and resizing capabilities respectively.</p>
<p>You can use the <code>all</code> feature to enable all features, including encoding features. This enables the widest range of
image format support, but adds a lot of dependencies you may not need.</p>
<p>For every image encoding that requires a dependency, a corresponding feature can be enabled for it:</p>
<div><table><thead><tr><th>Encoding</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>PNG and APNG</td><td><code>png</code></td><td><code>png</code></td><td>no</td></tr>
<tr><td>JPEG</td><td><code>jpeg</code></td><td><code>jpeg-decoder</code>, <code>jpeg-encoder</code></td><td>no</td></tr>
<tr><td>GIF</td><td><code>gif</code></td><td><code>gif</code></td><td>no</td></tr>
<tr><td>WebP</td><td><code>webp</code></td><td><code>libwebp-sys2</code></td><td>no</td></tr>
</tbody></table>
</div>
<p>Other features:</p>
<div><table><thead><tr><th>Description</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>Font/Text Rendering</td><td><code>text</code></td><td><code>fontdue</code></td><td>yes</td></tr>
<tr><td>Image Resizing</td><td><code>resize</code></td><td><code>fast_image_resize</code></td><td>yes</td></tr>
<tr><td>Color Quantization (using NeuQuant)</td><td><code>quantize</code></td><td><code>color_quant</code></td><td>yes</td></tr>
<tr><td>Gradients</td><td><code>gradient</code></td><td><code>colorgrad</code></td><td>yes</td></tr>
<tr><td>Enable all features,<br/> including all encoding features</td><td><code>all</code></td><td></td><td>no</td></tr>
</tbody></table>
</div><h4 id="webp-support-limitations"><a class="doc-anchor" href="#webp-support-limitations">§</a>WebP Support limitations</h4>
<p>WebP support uses <code>libwebp</code>, which is a native library. This means that if you try to use the
<code>webp</code> feature when compiling to a WebAssembly target, it might fail. We plan on making a
pure-Rust port of <code>libwebp</code> in the future.</p>
<p>For ease of use, the <code>all-pure</code> feature is provided, which is the equivalent of <code>all</code> minus the
<code>webp</code> feature.</p>
<h2 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting Started</h2>
<p>Import the prelude which brings commonly used types and crucial traits into scope:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;</code></pre></div>
<p>Because all errors from this crate are of the same type, ril provides a <code>Result</code> type
which you can use in any function that leverages ril, such as the <code>main</code> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() -&gt; ril::Result&lt;()&gt; {
    <span class="comment">// code goes here...

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Now you can use the <code>?</code> operator on anything that returns a <code>Result</code> for convenience.</p>
<h2 id="brief-guide"><a class="doc-anchor" href="#brief-guide">§</a>Brief Guide</h2>
<p>A quick guide and overview of ril’s interface.</p>
<h3 id="opening-an-image"><a class="doc-anchor" href="#opening-an-image">§</a>Opening an image</h3>
<p>The <a href="struct.Image.html#method.open" title="associated function ril::Image::open"><code>open</code></a> method should suit your needs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::open(<span class="string">"my_image.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The sole argument can be anything that implements <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef"><code>AsRef&lt;Path&gt;</code></a>, such as
a string or a file.</p>
<p>You might have also noticed that <a href="struct.Image.html" title="struct ril::Image"><code>Image</code></a> is generic with one type parameter,
which can be anything that implements <a href="trait.Pixel.html" title="trait ril::Pixel"><code>Pixel</code></a>. It represents what type of pixel
this image has - in this case, the image has RGB pixels.</p>
<p>Common pixel formats are <a href="struct.Rgb.html" title="struct ril::Rgb"><code>Rgb</code></a> (colored) and <a href="struct.Rgba.html" title="struct ril::Rgba"><code>Rgba</code></a> (colored with transparency),
which are found in the prelude. There are also grayscale counterparts, such as <a href="struct.L.html" title="struct ril::L"><code>L</code></a>.</p>
<h4 id="reading-from-a-byte-stream"><a class="doc-anchor" href="#reading-from-a-byte-stream">§</a>Reading from a byte stream</h4>
<p>You can also read from raw bytes using [<code>from_bytes</code>][Image::decode_from_bytes]:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="macro">include_bytes!</span>(<span class="string">"image.png"</span>) <span class="kw">as </span><span class="kw-2">&amp;</span>[u8]; <span class="comment">// Replace this with your own image data
</span><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes(ImageFormat::Png, bytes)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is a slice of bytes, or anything
that implements [<code>AsRef&lt;[u8]&gt;</code>].</p>
<p>You can also use <a href="struct.Image.html#method.from_bytes_inferred" title="associated function ril::Image::from_bytes_inferred"><code>from_bytes_inferred</code></a> to
infer the format from the byte slice without having to explicitly provide an encoding:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes_inferred(bytes)<span class="question-mark">?</span>;</code></pre></div>
<h3 id="creating-your-own-image"><a class="doc-anchor" href="#creating-your-own-image">§</a>Creating your own image</h3>
<p>You can create your own image using the <a href="struct.Image.html#method.new" title="associated function ril::Image::new"><code>Image::new</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
<p>The above creates a 256x256 RGB image with all pixels set to red.</p>
<p>The first argument is the width of the image, the second is the height, and the third is the
fill color. The pixel type of the image can be inferred from this argument, which is why we
don’t have to specify it explicitly as a type argument - Rust type inference is powerful and
infers this for us.</p>
<h4 id="the-from_fn-method"><a class="doc-anchor" href="#the-from_fn-method">§</a>The <code>from_fn</code> method</h4>
<p>The <a href="struct.Image.html#method.from_fn" title="associated function ril::Image::from_fn"><code>from_fn</code></a> method is a shortcut for creating an image from a function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::from_fn(<span class="number">256</span>, <span class="number">256</span>, |x, y| {
    <span class="comment">// Do something, maybe with `x` and `y`, and return a pixel
    </span>Rgb::new(x <span class="kw">as </span>u8, y <span class="kw">as </span>u8, <span class="number">0</span>)
});</code></pre></div>
<p>The above is just an example. You specify the width, height, and the function that
generates the pixels. It should take two parameters - <code>x</code> and <code>y</code>, which specify the position
of the pixel to generate - and return a pixel.</p>
<h3 id="encoding-and-saving-images"><a class="doc-anchor" href="#encoding-and-saving-images">§</a>Encoding and saving images</h3>
<p>You can encode and save an image to a file with the <a href="struct.Image.html#method.save" title="method ril::Image::save"><code>save</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Here's the red image from before:
</span><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));

image.save(ImageFormat::Png, <span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is the path to the file.</p>
<p>You may have noticed this is a bit repetitive, and that it is possible to infer the encoding
from the file extension. In cases like this, you can use the slightly slower
<a href="struct.Image.html#method.save_inferred" title="method ril::Image::save_inferred"><code>save_inferred</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>image.save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Now, you do not have to explicitly specify the encoding as it is inferred from the output path.</p>
<h4 id="encoding-and-saving-images-to-memory"><a class="doc-anchor" href="#encoding-and-saving-images-to-memory">§</a>Encoding and saving images to memory</h4>
<p>You can encode images to a memory buffer by using the <a href="struct.Image.html#method.encode" title="method ril::Image::encode"><code>encode</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>out = Vec::new();
image.encode(ImageFormat::Png, <span class="kw-2">&amp;mut </span>out)<span class="question-mark">?</span>;

<span class="comment">// Do something with `out`</span></code></pre></div>
<p>The first argument is the encoding of the image, and the second is the output buffer that must
implement <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html" title="trait std::io::Write"><code>Write</code></a>.</p>
<p>There is no filename to infer the encoding from, so in this case you have to explicitly
specify the encoding.</p>
<h3 id="manipulating-images"><a class="doc-anchor" href="#manipulating-images">§</a>Manipulating images</h3>
<p>Now that you know how to create and save images, let’s look at some of the ways we can modify
them!</p>
<h4 id="inverting-images"><a class="doc-anchor" href="#inverting-images">§</a>Inverting images</h4>
<p>A common manipulation method would be inverting every pixel in the image. To do this, there are
two methods which you can use:</p>
<ul>
<li><a href="struct.Image.html#method.invert" title="method ril::Image::invert"><code>invert</code></a>: Inverts the image in-place</li>
<li><a href="struct.Image.html#method.inverted" title="method ril::Image::inverted"><code>inverted</code></a>: Consumes the image and returns a new image with the inverted pixels</li>
</ul>
<p>A common pattern you’ll see in this crate is that many methods have an in-place method and a
not-in-place counterpart, in which the former can be useful for method chaining. One usually does
not have any memory or performance benefits than the other.</p>
<p>Anyhow, here’s how you’d invert an image:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));
image.invert();
image.save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p><code>(255, 0, 0)</code> (red) inverts to <code>(0, 255, 255)</code> (cyan), so that should be the color of the
output image.</p>
<p>We can also use the <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not"><code>std::ops::Not</code></a> trait to invert an image:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));
(!image).save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Seems to be a bit cleaner than the first way, but it really just comes down to preference…
and whether or not you have ownership of the image object; you likely want to stay away from
cloning images for no benefit as it is a very expensive operation.</p>
<p>TODO: finish guide</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="draw/index.html" title="mod ril::draw">draw</a></div><div class="desc docblock-short">Encloses most drawing implementations and drawable objects.</div></li><li><div class="item-name"><a class="mod" href="encode/index.html" title="mod ril::encode">encode</a></div><div class="desc docblock-short">Houses Encoder, Decoder, and frame iterator traits.</div></li><li><div class="item-name"><a class="mod" href="encodings/index.html" title="mod ril::encodings">encodings</a></div><div class="desc docblock-short">Contains encoder and decoder implementations for various image formats.</div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod ril::error">error</a></div><div class="desc docblock-short">Common error types.</div></li><li><div class="item-name"><a class="mod" href="fill/index.html" title="mod ril::fill">fill</a></div></li><li><div class="item-name"><a class="mod" href="filter/index.html" title="mod ril::filter">filter</a></div><div class="desc docblock-short">Filters that can be applied on images.</div></li><li><div class="item-name"><a class="mod" href="gradient/index.html" title="mod ril::gradient">gradient</a></div><div class="desc docblock-short">Handles rendering and logic of gradients.</div></li><li><div class="item-name"><a class="mod" href="pixel/index.html" title="mod ril::pixel">pixel</a></div><div class="desc docblock-short">Encloses pixel-related traits and pixel type implementations.</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod ril::prelude">prelude</a></div><div class="desc docblock-short">The crate prelude exports. Importing this with a wildcard will import most items from RIL that
can be useful for image processing, along with bringing crucial traits into scope.</div></li><li><div class="item-name"><a class="mod" href="quantize/index.html" title="mod ril::quantize">quantize</a></div><div class="desc docblock-short">Quantizes unpaletted pixel data to paletted data by quantizing the colors into a palette.</div></li><li><div class="item-name"><a class="mod" href="sequence/index.html" title="mod ril::sequence">sequence</a></div><div class="desc docblock-short">Implements the animated image and image sequence interface.</div></li><li><div class="item-name"><a class="mod" href="text/index.html" title="mod ril::text">text</a></div><div class="desc docblock-short">Implements the font/text rasterizing and layout interface.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BitPixel.html" title="struct ril::BitPixel">BitPixel</a></div><div class="desc docblock-short">Represents a single-bit pixel that represents either a pixel that is on or off.</div></li><li><div class="item-name"><a class="struct" href="struct.Border.html" title="struct ril::Border">Border</a></div><div class="desc docblock-short">Represents a shape border.</div></li><li><div class="item-name"><a class="struct" href="struct.ConicGradient.html" title="struct ril::ConicGradient">ConicGradient</a></div><div class="desc docblock-short">A conic gradient.</div></li><li><div class="item-name"><a class="struct" href="struct.Ellipse.html" title="struct ril::Ellipse">Ellipse</a></div><div class="desc docblock-short">An ellipse, which could be a circle.</div></li><li><div class="item-name"><a class="struct" href="struct.EncoderMetadata.html" title="struct ril::EncoderMetadata">EncoderMetadata</a></div><div class="desc docblock-short">Manually configured encoder metadata. This is used to provide fine-grained control over the
encoder. Not all encoders will use/consider all of these options.</div></li><li><div class="item-name"><a class="struct" href="struct.Font.html" title="struct ril::Font">Font</a></div><div class="desc docblock-short">Represents a single font along with its alternatives used to render text.
Currently, this supports TrueType and OpenType fonts.</div></li><li><div class="item-name"><a class="struct" href="struct.Frame.html" title="struct ril::Frame">Frame</a></div><div class="desc docblock-short">Represents a frame in an image sequence. It encloses an <a href="struct.Image.html" title="struct ril::Image"><code>Image</code></a> and extra metadata
about the frame.</div></li><li><div class="item-name"><a class="struct" href="struct.Image.html" title="struct ril::Image">Image</a></div><div class="desc docblock-short">A high-level image representation.</div></li><li><div class="item-name"><a class="struct" href="struct.ImageSequence.html" title="struct ril::ImageSequence">ImageSequence</a></div><div class="desc docblock-short">Represents a sequence of image frames such as an animated image.</div></li><li><div class="item-name"><a class="struct" href="struct.L.html" title="struct ril::L">L</a></div><div class="desc docblock-short">Represents an L, or luminance pixel that is stored as only one single
number representing how bright, or intense, the pixel is.</div></li><li><div class="item-name"><a class="struct" href="struct.Line.html" title="struct ril::Line">Line</a></div><div class="desc docblock-short">A line.</div></li><li><div class="item-name"><a class="struct" href="struct.LinearGradient.html" title="struct ril::LinearGradient">LinearGradient</a></div><div class="desc docblock-short">A linear gradient.</div></li><li><div class="item-name"><a class="struct" href="struct.PalettedRgb.html" title="struct ril::PalettedRgb">PalettedRgb</a></div><div class="desc docblock-short">Represents a paletted pixel, holding an index to a palette of Rgb colors represented as a <code>&amp;'p [Rgb]</code>, where <code>'p</code> is the lifetime of the palette.</div></li><li><div class="item-name"><a class="struct" href="struct.PalettedRgba.html" title="struct ril::PalettedRgba">PalettedRgba</a></div><div class="desc docblock-short">Represents a paletted pixel, holding an index to a palette of Rgba colors represented as a <code>&amp;'p [Rgba]</code>, where <code>'p</code> is the lifetime of the palette.</div></li><li><div class="item-name"><a class="struct" href="struct.Paste.html" title="struct ril::Paste">Paste</a></div><div class="desc docblock-short">Pastes or overlays an image on top of another image.</div></li><li><div class="item-name"><a class="struct" href="struct.Polygon.html" title="struct ril::Polygon">Polygon</a></div><div class="desc docblock-short">A polygon.</div></li><li><div class="item-name"><a class="struct" href="struct.Quantizer.html" title="struct ril::Quantizer">Quantizer</a></div><div class="desc docblock-short">Configuration options regarding behavior of quantization.</div></li><li><div class="item-name"><a class="struct" href="struct.RadialGradient.html" title="struct ril::RadialGradient">RadialGradient</a></div><div class="desc docblock-short">A radial gradient.</div></li><li><div class="item-name"><a class="struct" href="struct.Rectangle.html" title="struct ril::Rectangle">Rectangle</a></div><div class="desc docblock-short">A rectangle.</div></li><li><div class="item-name"><a class="struct" href="struct.Rgb.html" title="struct ril::Rgb">Rgb</a></div><div class="desc docblock-short">Represents an RGB pixel.</div></li><li><div class="item-name"><a class="struct" href="struct.Rgba.html" title="struct ril::Rgba">Rgba</a></div><div class="desc docblock-short">Represents an RGBA pixel.</div></li><li><div class="item-name"><a class="struct" href="struct.SingleFrameIterator.html" title="struct ril::SingleFrameIterator">SingleFrameIterator</a></div><div class="desc docblock-short">Represents a single static image wrapped in a frame iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.TextLayout.html" title="struct ril::TextLayout">TextLayout</a></div><div class="desc docblock-short">Represents a high-level text layout that can layout text segments, maybe with different fonts.</div></li><li><div class="item-name"><a class="struct" href="struct.TextSegment.html" title="struct ril::TextSegment">TextSegment</a></div><div class="desc docblock-short">Represents a text segment that can be drawn.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.BorderPosition.html" title="enum ril::BorderPosition">BorderPosition</a></div><div class="desc docblock-short">Represents whether a border is inset, outset, or if it lays in the center.</div></li><li><div class="item-name"><a class="enum" href="enum.ColorType.html" title="enum ril::ColorType">ColorType</a></div><div class="desc docblock-short">Represents an arbitrary color type. Note that this does not store the bit-depth or the type used
to store the value of each channel, although it can specify the number of channels.</div></li><li><div class="item-name"><a class="enum" href="enum.DisposalMethod.html" title="enum ril::DisposalMethod">DisposalMethod</a></div><div class="desc docblock-short">The method used to dispose a frame before transitioning to the next frame in an image sequence.</div></li><li><div class="item-name"><a class="enum" href="enum.Dynamic.html" title="enum ril::Dynamic">Dynamic</a></div><div class="desc docblock-short">Represents a pixel type that is dynamically resolved.</div></li><li><div class="item-name"><a class="enum" href="enum.DynamicSubpixel.html" title="enum ril::DynamicSubpixel">DynamicSubpixel</a></div><div class="desc docblock-short">Represents a subpixel of a dynamic pixel.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum ril::Error">Error</a></div><div class="desc docblock-short">Represents an error that occurs within the crate.</div></li><li><div class="item-name"><a class="enum" href="enum.GradientBlendMode.html" title="enum ril::GradientBlendMode">GradientBlendMode</a></div><div class="desc docblock-short">Color blending mode</div></li><li><div class="item-name"><a class="enum" href="enum.GradientInterpolation.html" title="enum ril::GradientInterpolation">GradientInterpolation</a></div><div class="desc docblock-short">Interpolation mode</div></li><li><div class="item-name"><a class="enum" href="enum.GradientPosition.html" title="enum ril::GradientPosition">GradientPosition</a></div><div class="desc docblock-short">Represents where the center of a radial or conic gradient is placed.</div></li><li><div class="item-name"><a class="enum" href="enum.HorizontalAnchor.html" title="enum ril::HorizontalAnchor">HorizontalAnchor</a></div><div class="desc docblock-short">Represents where text is anchored horizontally.</div></li><li><div class="item-name"><a class="enum" href="enum.ImageFormat.html" title="enum ril::ImageFormat">ImageFormat</a></div><div class="desc docblock-short">Represents the underlying encoding format of an image.</div></li><li><div class="item-name"><a class="enum" href="enum.LoopCount.html" title="enum ril::LoopCount">LoopCount</a></div><div class="desc docblock-short">Determines how many times an image sequence should repeat itself, or if it
should repeat infinitely.</div></li><li><div class="item-name"><a class="enum" href="enum.OverlayMode.html" title="enum ril::OverlayMode">OverlayMode</a></div><div class="desc docblock-short">The behavior to use when overlaying images on top of each other.</div></li><li><div class="item-name"><a class="enum" href="enum.RadialGradientCover.html" title="enum ril::RadialGradientCover">RadialGradientCover</a></div><div class="desc docblock-short">How a radial gradient should cover its shape if the aspect ratio of the bounding box != 1.</div></li><li><div class="item-name"><a class="enum" href="enum.ResizeAlgorithm.html" title="enum ril::ResizeAlgorithm">ResizeAlgorithm</a></div><div class="desc docblock-short">A filtering algorithm that is used to resize an image.</div></li><li><div class="item-name"><a class="enum" href="enum.TextAlign.html" title="enum ril::TextAlign">TextAlign</a></div><div class="desc docblock-short">Represents how to align text horizontally within its bounding box.</div></li><li><div class="item-name"><a class="enum" href="enum.VerticalAnchor.html" title="enum ril::VerticalAnchor">VerticalAnchor</a></div><div class="desc docblock-short">Represents where text is anchored vertically.</div></li><li><div class="item-name"><a class="enum" href="enum.WrapStyle.html" title="enum ril::WrapStyle">WrapStyle</a></div><div class="desc docblock-short">Determines how text should be wrapped.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Alpha.html" title="trait ril::Alpha">Alpha</a></div><div class="desc docblock-short">Represents a pixel that supports alpha, or transparency values.</div></li><li><div class="item-name"><a class="trait" href="trait.Banded.html" title="trait ril::Banded">Banded</a></div><div class="desc docblock-short">Represents an image with multiple channels, called bands.</div></li><li><div class="item-name"><a class="trait" href="trait.Decoder.html" title="trait ril::Decoder">Decoder</a></div><div class="desc docblock-short">Low-level decoder interface around an image format.</div></li><li><div class="item-name"><a class="trait" href="trait.Draw.html" title="trait ril::Draw">Draw</a></div><div class="desc docblock-short">A common trait for all objects able to be drawn on an image.</div></li><li><div class="item-name"><a class="trait" href="trait.Encoder.html" title="trait ril::Encoder">Encoder</a></div><div class="desc docblock-short">Low-level encoder interface around an image format. Typically only accessed for lazy encoding.</div></li><li><div class="item-name"><a class="trait" href="trait.Fill.html" title="trait ril::Fill">Fill</a></div><div class="desc docblock-short">Handles the actual filling of a shape. See <a href="trait.IntoFill.html" title="trait ril::IntoFill"><code>IntoFill</code></a> for more information.</div></li><li><div class="item-name"><a class="trait" href="trait.FrameIterator.html" title="trait ril::FrameIterator">FrameIterator</a></div><div class="desc docblock-short">Represents the lazy decoding of frames from an encoded image sequence, such as an animated
image.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoFill.html" title="trait ril::IntoFill">IntoFill</a></div><div class="desc docblock-short">Any fill type that can be used to fill a shape, i.e. solid colors or gradients.</div></li><li><div class="item-name"><a class="trait" href="trait.Paletted.html" title="trait ril::Paletted">Paletted</a></div><div class="desc docblock-short">A trait representing a paletted pixel. <a href="trait.Pixel.html#associatedtype.Subpixel" title="associated type ril::Pixel::Subpixel"><code>Pixel::Subpixel</code></a> is the type of the palette index.</div></li><li><div class="item-name"><a class="trait" href="trait.Pixel.html" title="trait ril::Pixel">Pixel</a></div><div class="desc docblock-short">Represents any type of pixel in an image.</div></li><li><div class="item-name"><a class="trait" href="trait.TrueColor.html" title="trait ril::TrueColor">TrueColor</a></div><div class="desc docblock-short">A trait representing all pixels that can be safely represented as either RGB or RGBA true color.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type ril::Result">Result</a></div><div class="desc docblock-short">A shortcut type equivalent to <code>Result&lt;T, ril::Error&gt;</code>.</div></li></ul></section></div></main></body></html>