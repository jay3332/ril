<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Rust Imaging Library. A performant and high-level image processing crate for Rust."><title>ril - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ril" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ril/index.html">ril</a><span class="version">0.10.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#installation" title="Installation">Installation</a><ul><li><a href="#installing-from-github" title="Installing from GitHub">Installing from GitHub</a></li><li><a href="#using-cargo-add" title="Using `cargo add`">Using <code>cargo add</code></a></li><li><a href="#cargo-features" title="Cargo Features">Cargo Features</a></li></ul></li><li><a href="#getting-started" title="Getting Started">Getting Started</a></li><li><a href="#brief-guide" title="Brief Guide">Brief Guide</a><ul><li><a href="#opening-an-image" title="Opening an image">Opening an image</a></li><li><a href="#creating-your-own-image" title="Creating your own image">Creating your own image</a></li><li><a href="#encoding-and-saving-images" title="Encoding and saving images">Encoding and saving images</a></li><li><a href="#manipulating-images" title="Manipulating images">Manipulating images</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>ril</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ril/lib.rs.html#1-356">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The Rust Imaging Library. A performant and high-level image processing crate for Rust.</p>
<p>See benchmarks and more by viewing the <a href="https://github.com/jay3332/ril#ril">README</a>. It should
also be noted that the README is updated more frequently than the documentation.</p>
<p>Similarly, you can see the changelog <a href="https://github.com/jay3332/ril/blob/main/CHANGELOG.md">here</a>.</p>
<h2 id="installation"><a class="doc-anchor" href="#installation">§</a>Installation</h2>
<p>The MSRV (Minimum Supported Rust Version) of this crate is <strong>v1.61.0</strong>.</p>
<p>Add the following to your <code>Cargo.toml</code> dependencies:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { version = &quot;0&quot;, features = [&quot;all&quot;] ]</code></pre></div><h3 id="installing-from-github"><a class="doc-anchor" href="#installing-from-github">§</a>Installing from GitHub</h3>
<p>You can also use the unstable but latest version by installing from GitHub:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { git = &quot;https://github.com/jay3332/ril&quot;, branch = &quot;main&quot;, features = [&quot;all&quot;] }</code></pre></div><h3 id="using-cargo-add"><a class="doc-anchor" href="#using-cargo-add">§</a>Using <code>cargo add</code></h3>
<p>If you have cargo &gt;= 1.62.0, you can use <code>cargo add ril --features=all</code>.</p>
<h3 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo Features</h3>
<p>RIL currently depends on a few dependencies for certain features - especially for various image encodings.
By default RIL comes with no encoding dependencies but with the <code>text</code> and <code>resize</code> dependencies, which give you text
and resizing capabilities respectively.</p>
<p>You can use the <code>all</code> feature to enable all features, including encoding features. This enables the widest range of
image format support, but adds a lot of dependencies you may not need.</p>
<p>For every image encoding that requires a dependency, a corresponding feature can be enabled for it:</p>
<div><table><thead><tr><th>Encoding</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>PNG and APNG</td><td><code>png</code></td><td><code>png</code></td><td>no</td></tr>
<tr><td>JPEG</td><td><code>jpeg</code></td><td><code>jpeg-decoder</code>, <code>jpeg-encoder</code></td><td>no</td></tr>
<tr><td>GIF</td><td><code>gif</code></td><td><code>gif</code></td><td>no</td></tr>
<tr><td>WebP</td><td><code>webp</code></td><td><code>libwebp-sys2</code></td><td>no</td></tr>
</tbody></table>
</div>
<p>Other features:</p>
<div><table><thead><tr><th>Description</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>Font/Text Rendering</td><td><code>text</code></td><td><code>fontdue</code></td><td>yes</td></tr>
<tr><td>Image Resizing</td><td><code>resize</code></td><td><code>fast_image_resize</code></td><td>yes</td></tr>
<tr><td>Color Quantization (using NeuQuant)</td><td><code>quantize</code></td><td><code>color_quant</code></td><td>yes</td></tr>
<tr><td>Gradients</td><td><code>gradient</code></td><td><code>colorgrad</code></td><td>yes</td></tr>
<tr><td>Enable all features,<br/> including all encoding features</td><td><code>all</code></td><td></td><td>no</td></tr>
</tbody></table>
</div><h4 id="webp-support-limitations"><a class="doc-anchor" href="#webp-support-limitations">§</a>WebP Support limitations</h4>
<p>WebP support uses <code>libwebp</code>, which is a native library. This means that if you try to use the
<code>webp</code> feature when compiling to a WebAssembly target, it might fail. We plan on making a
pure-Rust port of <code>libwebp</code> in the future.</p>
<p>For ease of use, the <code>all-pure</code> feature is provided, which is the equivalent of <code>all</code> minus the
<code>webp</code> feature.</p>
<h2 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting Started</h2>
<p>Import the prelude which brings commonly used types and crucial traits into scope:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;</code></pre></div>
<p>Because all errors from this crate are of the same type, ril provides a <code>Result</code> type
which you can use in any function that leverages ril, such as the <code>main</code> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() -&gt; ril::Result&lt;()&gt; {
    <span class="comment">// code goes here...

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Now you can use the <code>?</code> operator on anything that returns a <code>Result</code> for convenience.</p>
<h2 id="brief-guide"><a class="doc-anchor" href="#brief-guide">§</a>Brief Guide</h2>
<p>A quick guide and overview of ril’s interface.</p>
<h3 id="opening-an-image"><a class="doc-anchor" href="#opening-an-image">§</a>Opening an image</h3>
<p>The <a href="struct.Image.html#method.open" title="associated function ril::Image::open"><code>open</code></a> method should suit your needs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::open(<span class="string">"my_image.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The sole argument can be anything that implements <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef"><code>AsRef&lt;Path&gt;</code></a>, such as
a string or a file.</p>
<p>You might have also noticed that <a href="struct.Image.html" title="struct ril::Image"><code>Image</code></a> is generic with one type parameter,
which can be anything that implements <a href="trait.Pixel.html" title="trait ril::Pixel"><code>Pixel</code></a>. It represents what type of pixel
this image has - in this case, the image has RGB pixels.</p>
<p>Common pixel formats are <a href="struct.Rgb.html" title="struct ril::Rgb"><code>Rgb</code></a> (colored) and <a href="struct.Rgba.html" title="struct ril::Rgba"><code>Rgba</code></a> (colored with transparency),
which are found in the prelude. There are also grayscale counterparts, such as <a href="struct.Luma.html" title="struct ril::Luma"><code>Luma</code></a>.</p>
<h4 id="reading-from-a-byte-stream"><a class="doc-anchor" href="#reading-from-a-byte-stream">§</a>Reading from a byte stream</h4>
<p>You can also read from raw bytes using [<code>from_bytes</code>][Image::decode_from_bytes]:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="macro">include_bytes!</span>(<span class="string">"image.png"</span>) <span class="kw">as </span><span class="kw-2">&amp;</span>[u8]; <span class="comment">// Replace this with your own image data
</span><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes(ImageFormat::Png, bytes)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is a slice of bytes, or anything
that implements [<code>AsRef&lt;[u8]&gt;</code>].</p>
<p>You can also use <a href="struct.Image.html#method.from_bytes_inferred" title="associated function ril::Image::from_bytes_inferred"><code>from_bytes_inferred</code></a> to
infer the format from the byte slice without having to explicitly provide an encoding:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes_inferred(bytes)<span class="question-mark">?</span>;</code></pre></div>
<h3 id="creating-your-own-image"><a class="doc-anchor" href="#creating-your-own-image">§</a>Creating your own image</h3>
<p>You can create your own image using the <a href="struct.Image.html#method.new" title="associated function ril::Image::new"><code>Image::new</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
<p>The above creates a 256x256 RGB image with all pixels set to red.</p>
<p>The first argument is the width of the image, the second is the height, and the third is the
fill color. The pixel type of the image can be inferred from this argument, which is why we
don’t have to specify it explicitly as a type argument - Rust type inference is powerful and
infers this for us.</p>
<h4 id="the-from_fn-method"><a class="doc-anchor" href="#the-from_fn-method">§</a>The <code>from_fn</code> method</h4>
<p>The <a href="struct.Image.html#method.from_fn" title="associated function ril::Image::from_fn"><code>from_fn</code></a> method is a shortcut for creating an image from a function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::from_fn(<span class="number">256</span>, <span class="number">256</span>, |x, y| {
    <span class="comment">// Do something, maybe with `x` and `y`, and return a pixel
    </span>Rgb::new(x <span class="kw">as </span>u8, y <span class="kw">as </span>u8, <span class="number">0</span>)
});</code></pre></div>
<p>The above is just an example. You specify the width, height, and the function that
generates the pixels. It should take two parameters - <code>x</code> and <code>y</code>, which specify the position
of the pixel to generate - and return a pixel.</p>
<h3 id="encoding-and-saving-images"><a class="doc-anchor" href="#encoding-and-saving-images">§</a>Encoding and saving images</h3>
<p>You can encode and save an image to a file with the <a href="struct.Image.html#method.save" title="method ril::Image::save"><code>save</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Here's the red image from before:
</span><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));

image.save(ImageFormat::Png, <span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is the path to the file.</p>
<p>You may have noticed this is a bit repetitive, and that it is possible to infer the encoding
from the file extension. In cases like this, you can use the slightly slower
<a href="struct.Image.html#method.save_inferred" title="method ril::Image::save_inferred"><code>save_inferred</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>image.save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Now, you do not have to explicitly specify the encoding as it is inferred from the output path.</p>
<h4 id="encoding-and-saving-images-to-memory"><a class="doc-anchor" href="#encoding-and-saving-images-to-memory">§</a>Encoding and saving images to memory</h4>
<p>You can encode images to a memory buffer by using the <a href="struct.Image.html#method.encode" title="method ril::Image::encode"><code>encode</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>out = Vec::new();
image.encode(ImageFormat::Png, <span class="kw-2">&amp;mut </span>out)<span class="question-mark">?</span>;

<span class="comment">// Do something with `out`</span></code></pre></div>
<p>The first argument is the encoding of the image, and the second is the output buffer that must
implement <a href="https://doc.rust-lang.org/1.89.0/std/io/trait.Write.html" title="trait std::io::Write"><code>Write</code></a>.</p>
<p>There is no filename to infer the encoding from, so in this case you have to explicitly
specify the encoding.</p>
<h3 id="manipulating-images"><a class="doc-anchor" href="#manipulating-images">§</a>Manipulating images</h3>
<p>Now that you know how to create and save images, let’s look at some of the ways we can modify
them!</p>
<h4 id="inverting-images"><a class="doc-anchor" href="#inverting-images">§</a>Inverting images</h4>
<p>A common manipulation method would be inverting every pixel in the image. To do this, there are
two methods which you can use:</p>
<ul>
<li><a href="struct.Image.html#method.invert" title="method ril::Image::invert"><code>invert</code></a>: Inverts the image in-place</li>
<li><a href="struct.Image.html#method.inverted" title="method ril::Image::inverted"><code>inverted</code></a>: Consumes the image and returns a new image with the inverted pixels</li>
</ul>
<p>A common pattern you’ll see in this crate is that many methods have an in-place method and a
not-in-place counterpart, in which the former can be useful for method chaining. One usually does
not have any memory or performance benefits than the other.</p>
<p>Anyhow, here’s how you’d invert an image:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));
image.invert();
image.save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p><code>(255, 0, 0)</code> (red) inverts to <code>(0, 255, 255)</code> (cyan), so that should be the color of the
output image.</p>
<p>We can also use the <a href="https://doc.rust-lang.org/1.89.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not"><code>std::ops::Not</code></a> trait to invert an image:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));
(!image).save_inferred(<span class="string">"output.png"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Seems to be a bit cleaner than the first way, but it really just comes down to preference…
and whether or not you have ownership of the image object; you likely want to stay away from
cloning images for no benefit as it is a very expensive operation.</p>
<p>TODO: finish guide</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="colors/index.html" title="mod ril::colors">colors</a></dt><dd>RGB color constants, which includes all preset colors specified in X11/CSS3.</dd><dt><a class="mod" href="draw/index.html" title="mod ril::draw">draw</a></dt><dd>Encloses most drawing implementations and drawable objects.</dd><dt><a class="mod" href="encode/index.html" title="mod ril::encode">encode</a></dt><dd>Houses Encoder, Decoder, and frame iterator traits.</dd><dt><a class="mod" href="encodings/index.html" title="mod ril::encodings">encodings</a></dt><dd>Contains encoder and decoder implementations for various image formats.</dd><dt><a class="mod" href="error/index.html" title="mod ril::error">error</a></dt><dd>Common error types.</dd><dt><a class="mod" href="fill/index.html" title="mod ril::fill">fill</a></dt><dd>Includes the <a href="trait.Fill.html" title="trait ril::Fill"><code>Fill</code></a> and <a href="trait.IntoFill.html" title="trait ril::IntoFill"><code>IntoFill</code></a> traits and primitive fill types such as <a href="fill/struct.SolidFill.html" title="struct ril::fill::SolidFill"><code>SolidFill</code></a>.</dd><dt><a class="mod" href="filter/index.html" title="mod ril::filter">filter</a></dt><dd>Filters that can be applied on images.</dd><dt><a class="mod" href="gradient/index.html" title="mod ril::gradient">gradient</a></dt><dd>Handles rendering and logic of gradients.</dd><dt><a class="mod" href="pixel/index.html" title="mod ril::pixel">pixel</a></dt><dd>Encloses pixel-related traits and pixel type implementations.</dd><dt><a class="mod" href="prelude/index.html" title="mod ril::prelude">prelude</a></dt><dd>The crate prelude exports. Importing this with a wildcard will import most items from RIL that
can be useful for image processing, along with bringing crucial traits into scope.</dd><dt><a class="mod" href="quantize/index.html" title="mod ril::quantize">quantize</a></dt><dd>Quantizes unpaletted pixel data to paletted data by quantizing the colors into a palette.</dd><dt><a class="mod" href="sequence/index.html" title="mod ril::sequence">sequence</a></dt><dd>Implements the animated image and image sequence interface.</dd><dt><a class="mod" href="text/index.html" title="mod ril::text">text</a></dt><dd>Implements the font/text rasterizing and layout interface.</dd><dt><a class="mod" href="vector/index.html" title="mod ril::vector">vector</a></dt><dd>Defines the <a href="struct.Vector.html" title="struct ril::Vector"><code>Vector</code></a> type and associated traits for vector operations.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BitPixel.html" title="struct ril::BitPixel">BitPixel</a></dt><dd>Represents a single-bit pixel that represents either a pixel that is on or off.</dd><dt><a class="struct" href="struct.Border.html" title="struct ril::Border">Border</a></dt><dd>Represents a shape border.</dd><dt><a class="struct" href="struct.ConicGradient.html" title="struct ril::ConicGradient">Conic<wbr>Gradient</a></dt><dd>A conic gradient.</dd><dt><a class="struct" href="struct.Convolution.html" title="struct ril::Convolution">Convolution</a></dt><dd>A statically-sized filter that performs a convolution between the given fixed-size kernel matrix
and the image.</dd><dt><a class="struct" href="struct.DynamicConvolution.html" title="struct ril::DynamicConvolution">Dynamic<wbr>Convolution</a></dt><dd>A convolution filter where the kernel matrix is dynamically allocated.</dd><dt><a class="struct" href="struct.Ellipse.html" title="struct ril::Ellipse">Ellipse</a></dt><dd>An ellipse, which could be a circle.</dd><dt><a class="struct" href="struct.EncoderMetadata.html" title="struct ril::EncoderMetadata">Encoder<wbr>Metadata</a></dt><dd>Manually configured encoder metadata. This is used to provide fine-grained control over the
encoder. Not all encoders will use/consider all of these options.</dd><dt><a class="struct" href="struct.Font.html" title="struct ril::Font">Font</a></dt><dd>Represents a single font along with its alternatives used to render text.
Currently, this supports TrueType and OpenType fonts.</dd><dt><a class="struct" href="struct.Frame.html" title="struct ril::Frame">Frame</a></dt><dd>Represents a frame in an image sequence. It encloses an <a href="struct.Image.html" title="struct ril::Image"><code>Image</code></a> and extra metadata
about the frame.</dd><dt><a class="struct" href="struct.Image.html" title="struct ril::Image">Image</a></dt><dd>A high-level image representation.</dd><dt><a class="struct" href="struct.ImageSequence.html" title="struct ril::ImageSequence">Image<wbr>Sequence</a></dt><dd>Represents a sequence of image frames such as an animated image.</dd><dt><a class="struct" href="struct.Line.html" title="struct ril::Line">Line</a></dt><dd>A line.</dd><dt><a class="struct" href="struct.LinearGradient.html" title="struct ril::LinearGradient">Linear<wbr>Gradient</a></dt><dd>A linear gradient.</dd><dt><a class="struct" href="struct.Luma.html" title="struct ril::Luma">Luma</a></dt><dd>Represents a luminance pixel that is stored as only one single number representing how bright,
or intense, the pixel is.</dd><dt><a class="struct" href="struct.PalettedRgb.html" title="struct ril::PalettedRgb">Paletted<wbr>Rgb</a></dt><dd>Represents a paletted pixel, holding an index to a palette of Rgb colors represented as a <code>&amp;'p [Rgb]</code>, where <code>'p</code> is the lifetime of the palette.</dd><dt><a class="struct" href="struct.PalettedRgba.html" title="struct ril::PalettedRgba">Paletted<wbr>Rgba</a></dt><dd>Represents a paletted pixel, holding an index to a palette of Rgba colors represented as a <code>&amp;'p [Rgba]</code>, where <code>'p</code> is the lifetime of the palette.</dd><dt><a class="struct" href="struct.Paste.html" title="struct ril::Paste">Paste</a></dt><dd>Pastes or overlays an image on top of another image.</dd><dt><a class="struct" href="struct.Polygon.html" title="struct ril::Polygon">Polygon</a></dt><dd>A polygon.</dd><dt><a class="struct" href="struct.Quantizer.html" title="struct ril::Quantizer">Quantizer</a></dt><dd>Configuration options regarding behavior of quantization.</dd><dt><a class="struct" href="struct.RadialGradient.html" title="struct ril::RadialGradient">Radial<wbr>Gradient</a></dt><dd>A radial gradient.</dd><dt><a class="struct" href="struct.Rectangle.html" title="struct ril::Rectangle">Rectangle</a></dt><dd>A rectangle.</dd><dt><a class="struct" href="struct.Rgb.html" title="struct ril::Rgb">Rgb</a></dt><dd>Represents an RGB pixel.</dd><dt><a class="struct" href="struct.Rgba.html" title="struct ril::Rgba">Rgba</a></dt><dd>Represents an RGBA pixel.</dd><dt><a class="struct" href="struct.SingleFrameIterator.html" title="struct ril::SingleFrameIterator">Single<wbr>Frame<wbr>Iterator</a></dt><dd>Represents a single static image wrapped in a frame iterator.</dd><dt><a class="struct" href="struct.TextLayout.html" title="struct ril::TextLayout">Text<wbr>Layout</a></dt><dd>Represents a high-level text layout that can layout text segments, maybe with different fonts.</dd><dt><a class="struct" href="struct.TextSegment.html" title="struct ril::TextSegment">Text<wbr>Segment</a></dt><dd>Represents a text segment that can be drawn.</dd><dt><a class="struct" href="struct.Vector.html" title="struct ril::Vector">Vector</a></dt><dd>A mathematical vector represented using a fixed-sized array with elements of type <code>T</code>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BorderPosition.html" title="enum ril::BorderPosition">Border<wbr>Position</a></dt><dd>Represents whether a border is inset, outset, or if it lays in the center.</dd><dt><a class="enum" href="enum.ColorType.html" title="enum ril::ColorType">Color<wbr>Type</a></dt><dd>Represents an arbitrary color type. Note that this does not store the bit-depth or the type used
to store the value of each channel, although it can specify the number of channels.</dd><dt><a class="enum" href="enum.DisposalMethod.html" title="enum ril::DisposalMethod">Disposal<wbr>Method</a></dt><dd>The method used to dispose a frame before transitioning to the next frame in an image sequence.</dd><dt><a class="enum" href="enum.Dynamic.html" title="enum ril::Dynamic">Dynamic</a></dt><dd>Represents a pixel type that is dynamically resolved.</dd><dt><a class="enum" href="enum.DynamicSubpixel.html" title="enum ril::DynamicSubpixel">Dynamic<wbr>Subpixel</a></dt><dd>Represents a subpixel of a dynamic pixel.</dd><dt><a class="enum" href="enum.Error.html" title="enum ril::Error">Error</a></dt><dd>Represents an error that occurs within the crate.</dd><dt><a class="enum" href="enum.GradientBlendMode.html" title="enum ril::GradientBlendMode">Gradient<wbr>Blend<wbr>Mode</a></dt><dd>Color blending mode</dd><dt><a class="enum" href="enum.GradientInterpolation.html" title="enum ril::GradientInterpolation">Gradient<wbr>Interpolation</a></dt><dd>Interpolation mode</dd><dt><a class="enum" href="enum.GradientPosition.html" title="enum ril::GradientPosition">Gradient<wbr>Position</a></dt><dd>Represents where the center of a radial or conic gradient is placed.</dd><dt><a class="enum" href="enum.HorizontalAnchor.html" title="enum ril::HorizontalAnchor">Horizontal<wbr>Anchor</a></dt><dd>Represents where text is anchored horizontally.</dd><dt><a class="enum" href="enum.ImageFormat.html" title="enum ril::ImageFormat">Image<wbr>Format</a></dt><dd>Represents the underlying encoding format of an image.</dd><dt><a class="enum" href="enum.LoopCount.html" title="enum ril::LoopCount">Loop<wbr>Count</a></dt><dd>Determines how many times an image sequence should repeat itself, or if it
should repeat infinitely.</dd><dt><a class="enum" href="enum.OverlayMode.html" title="enum ril::OverlayMode">Overlay<wbr>Mode</a></dt><dd>The behavior to use when overlaying images on top of each other.</dd><dt><a class="enum" href="enum.RadialGradientCover.html" title="enum ril::RadialGradientCover">Radial<wbr>Gradient<wbr>Cover</a></dt><dd>How a radial gradient should cover its shape if the aspect ratio of the bounding box != 1.</dd><dt><a class="enum" href="enum.ResizeAlgorithm.html" title="enum ril::ResizeAlgorithm">Resize<wbr>Algorithm</a></dt><dd>A filtering algorithm that is used to resize an image.</dd><dt><a class="enum" href="enum.TextAlign.html" title="enum ril::TextAlign">Text<wbr>Align</a></dt><dd>Represents how to align text horizontally within its bounding box.</dd><dt><a class="enum" href="enum.VerticalAnchor.html" title="enum ril::VerticalAnchor">Vertical<wbr>Anchor</a></dt><dd>Represents where text is anchored vertically.</dd><dt><a class="enum" href="enum.WrapStyle.html" title="enum ril::WrapStyle">Wrap<wbr>Style</a></dt><dd>Determines how text should be wrapped.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Alpha.html" title="trait ril::Alpha">Alpha</a></dt><dd>Represents a pixel that supports alpha, or transparency values.</dd><dt><a class="trait" href="trait.Banded.html" title="trait ril::Banded">Banded</a></dt><dd>Represents an image with multiple channels, called bands.</dd><dt><a class="trait" href="trait.Decoder.html" title="trait ril::Decoder">Decoder</a></dt><dd>Low-level decoder interface around an image format.</dd><dt><a class="trait" href="trait.Draw.html" title="trait ril::Draw">Draw</a></dt><dd>A common trait for all objects able to be drawn on an image.</dd><dt><a class="trait" href="trait.Encoder.html" title="trait ril::Encoder">Encoder</a></dt><dd>Low-level encoder interface around an image format. Typically only accessed for lazy encoding.</dd><dt><a class="trait" href="trait.Fill.html" title="trait ril::Fill">Fill</a></dt><dd>Handles the actual filling of a shape. See <a href="trait.IntoFill.html" title="trait ril::IntoFill"><code>IntoFill</code></a> for more information.</dd><dt><a class="trait" href="trait.FrameIterator.html" title="trait ril::FrameIterator">Frame<wbr>Iterator</a></dt><dd>Represents the lazy decoding of frames from an encoded image sequence, such as an animated
image.</dd><dt><a class="trait" href="trait.FromVector.html" title="trait ril::FromVector">From<wbr>Vector</a></dt><dd>Vectorizable type trait. This trait is used to indicate that a type can be constructed from a
vector.</dd><dt><a class="trait" href="trait.IntoFill.html" title="trait ril::IntoFill">Into<wbr>Fill</a></dt><dd>Any fill type that can be used to fill a shape, i.e. solid colors or gradients.</dd><dt><a class="trait" href="trait.IntoVector.html" title="trait ril::IntoVector">Into<wbr>Vector</a></dt><dd>Vectorizable type trait. This trait is used to indicate that a type (usually a pixel) can
be represented as a statically-sized vector.</dd><dt><a class="trait" href="trait.Paletted.html" title="trait ril::Paletted">Paletted</a></dt><dd>A trait representing a paletted pixel. <a href="trait.Pixel.html#associatedtype.Subpixel" title="associated type ril::Pixel::Subpixel"><code>Pixel::Subpixel</code></a> is the type of the palette index.</dd><dt><a class="trait" href="trait.Pixel.html" title="trait ril::Pixel">Pixel</a></dt><dd>Represents any type of pixel in an image.</dd><dt><a class="trait" href="trait.TrueColor.html" title="trait ril::TrueColor">True<wbr>Color</a></dt><dd>A trait representing all pixels that can be safely represented as either RGB or RGBA true color.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Result.html" title="type ril::Result">Result</a></dt><dd>A shortcut type equivalent to <code>Result&lt;T, ril::Error&gt;</code>.</dd></dl></section></div></main></body></html>